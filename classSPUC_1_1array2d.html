<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>SPUC: SPUC::array2d&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SPUC
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSPUC.html">SPUC</a></li><li class="navelem"><a class="el" href="classSPUC_1_1array2d.html">array2d</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSPUC_1_1array2d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SPUC::array2d&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;array2d.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aefd1de564741221fc1fb50157cc6d09c"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#aefd1de564741221fc1fb50157cc6d09c">value_type</a></td></tr>
<tr class="separator:aefd1de564741221fc1fb50157cc6d09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5903f6a2b16c8c6f273049d26a17e22f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a5903f6a2b16c8c6f273049d26a17e22f">array2d</a> ()</td></tr>
<tr class="separator:a5903f6a2b16c8c6f273049d26a17e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7308b48a6b14b80b53c87ac1fbb126f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a7308b48a6b14b80b53c87ac1fbb126f9">array2d</a> (int m, int n)</td></tr>
<tr class="separator:a7308b48a6b14b80b53c87ac1fbb126f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf26b6239c2fadf3374bf7d747932f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#aaaf26b6239c2fadf3374bf7d747932f6">array2d</a> (int m, int n, T *a)</td></tr>
<tr class="separator:aaaf26b6239c2fadf3374bf7d747932f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d16d93a26e5e6d9daf16dc9033c619d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a0d16d93a26e5e6d9daf16dc9033c619d">array2d</a> (int m, int n, const T &amp;a)</td></tr>
<tr class="separator:a0d16d93a26e5e6d9daf16dc9033c619d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0040db469caf03d890a5384892c6caf6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a0040db469caf03d890a5384892c6caf6">array2d</a> (const <a class="el" href="classSPUC_1_1array2d.html">array2d</a> &amp;A)</td></tr>
<tr class="separator:a0040db469caf03d890a5384892c6caf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9e23c1c0fe0d5c0fa1956fac5ed292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSPUC_1_1array2d.html">array2d</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a3b9e23c1c0fe0d5c0fa1956fac5ed292">operator=</a> (const T &amp;a)</td></tr>
<tr class="separator:a3b9e23c1c0fe0d5c0fa1956fac5ed292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e8fc54006609111d84ed5f70c5e9d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSPUC_1_1array2d.html">array2d</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a03e8fc54006609111d84ed5f70c5e9d4">operator=</a> (const <a class="el" href="classSPUC_1_1array2d.html">array2d</a> &amp;A)</td></tr>
<tr class="separator:a03e8fc54006609111d84ed5f70c5e9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2453eaf12d3927f74a46be1fb817b882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSPUC_1_1array2d.html">array2d</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a2453eaf12d3927f74a46be1fb817b882">ref</a> (const <a class="el" href="classSPUC_1_1array2d.html">array2d</a> &amp;A)</td></tr>
<tr class="separator:a2453eaf12d3927f74a46be1fb817b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac59ca10d58b6ea5c424ed2c78246c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#aac59ca10d58b6ea5c424ed2c78246c5e">copy</a> () const </td></tr>
<tr class="separator:aac59ca10d58b6ea5c424ed2c78246c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1e3863657ba94c774d9827d84c290a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSPUC_1_1array2d.html">array2d</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a3c1e3863657ba94c774d9827d84c290a">inject</a> (const <a class="el" href="classSPUC_1_1array2d.html">array2d</a> &amp;A)</td></tr>
<tr class="separator:a3c1e3863657ba94c774d9827d84c290a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5cddffb7c62e630c364548f6034fb3"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a4a5cddffb7c62e630c364548f6034fb3">operator[]</a> (int i)</td></tr>
<tr class="separator:a4a5cddffb7c62e630c364548f6034fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a4f1106ef6e3f90b63352dba1916aa"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a68a4f1106ef6e3f90b63352dba1916aa">operator[]</a> (int i) const </td></tr>
<tr class="separator:a68a4f1106ef6e3f90b63352dba1916aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3211b58437f320f4142c37428937fdf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#af3211b58437f320f4142c37428937fdf">dim1</a> () const </td></tr>
<tr class="separator:af3211b58437f320f4142c37428937fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aabe161e81fadee2e2fe35a15423ff8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a7aabe161e81fadee2e2fe35a15423ff8">dim2</a> () const </td></tr>
<tr class="separator:a7aabe161e81fadee2e2fe35a15423ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6e791abe989e74dbae5746c2e37d90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#abc6e791abe989e74dbae5746c2e37d90">ref_count</a> () const </td></tr>
<tr class="separator:abc6e791abe989e74dbae5746c2e37d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11d75e0a88c4bccf8fbcee6e416e701"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#ab11d75e0a88c4bccf8fbcee6e416e701">~array2d</a> ()</td></tr>
<tr class="separator:ab11d75e0a88c4bccf8fbcee6e416e701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7099e0ef82df869dec72ae747091494b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a7099e0ef82df869dec72ae747091494b">cols</a> () const </td></tr>
<tr class="separator:a7099e0ef82df869dec72ae747091494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8b4259781c0da8112d16e1fcf9dcdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a3b8b4259781c0da8112d16e1fcf9dcdc">rows</a> () const </td></tr>
<tr class="separator:a3b8b4259781c0da8112d16e1fcf9dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e857975d53953620ba05a51ec1683e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#ac3e857975d53953620ba05a51ec1683e">newsize</a> (int m, int n)</td></tr>
<tr class="separator:ac3e857975d53953620ba05a51ec1683e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fd6dc2770156025ef8e4a3765e2420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPUC_1_1array2d.html#a66fd6dc2770156025ef8e4a3765e2420">set_size</a> (int m, int n)</td></tr>
<tr class="separator:a66fd6dc2770156025ef8e4a3765e2420"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class SPUC::array2d&lt; T &gt;</h3>

<p>Templated two-dimensional, numerical array which looks like a conventional C multiarray. Storage corresponds to C (row-major) ordering. Elements are accessed via A[i][j] notation.</p>
<p>Array assignment is by reference (i.e. shallow assignment). That is, B=A implies that the A and B point to the same array, so modifications to the elements of A will be reflected in B. If an independent copy is required, then B = A.copy() can be used. Note that this facilitates returning arrays from functions without relying on compiler optimizations to eliminate extensive data copying.</p>
<p>The indexing and layout of this array object makes it compatible with C and C++ algorithms that utilize the familiar C[i][j] notation. This includes numerous textbooks, such as Numercial Recipes, and various public domain codes.</p>
<p>This class employs its own garbage collection via the use of reference counts. That is, whenever an internal array storage no longer has any references to it, it is destoryed. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aefd1de564741221fc1fb50157cc6d09c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::<a class="el" href="classSPUC_1_1array2d.html#aefd1de564741221fc1fb50157cc6d09c">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5903f6a2b16c8c6f273049d26a17e22f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::<a class="el" href="classSPUC_1_1array2d.html">array2d</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a null (0x0) array. </p>

</div>
</div>
<a class="anchor" id="a7308b48a6b14b80b53c87ac1fbb126f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::<a class="el" href="classSPUC_1_1array2d.html">array2d</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new (m x n) array, WIHOUT initializing array elements. To create an initialized array of constants, see array2d(m,n,value).</p>
<p>This version avoids the O(m*n) initialization overhead and is used just before manual assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the first (row) dimension of the new matrix. </td></tr>
    <tr><td class="paramname">n</td><td>the second (column) dimension of the new matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaf26b6239c2fadf3374bf7d747932f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::<a class="el" href="classSPUC_1_1array2d.html">array2d</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new (m x n) array, as a view of an existing one-dimensional array stored in <b>C order</b>, i.e. right-most dimension varying fastest. (Often referred to as "row-major" ordering.) Note that the storage for this pre-existing array will never be garbage collected by the <a class="el" href="classSPUC_1_1array2d.html">array2d</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the first (row) dimension of the new matrix. </td></tr>
    <tr><td class="paramname">n</td><td>the second (column) dimension of the new matrix. </td></tr>
    <tr><td class="paramname">a</td><td>the one dimensional C array to use as data storage for the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d16d93a26e5e6d9daf16dc9033c619d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::<a class="el" href="classSPUC_1_1array2d.html">array2d</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new (m x n) array, initializing array elements to constant specified by argument. Most often used to create an array of zeros, as in A(m, n, 0.0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the first (row) dimension of the new matrix. </td></tr>
    <tr><td class="paramname">n</td><td>the second (column) dimension of the new matrix. </td></tr>
    <tr><td class="paramname">val</td><td>the constant value to set all elements of the new array to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0040db469caf03d890a5384892c6caf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::<a class="el" href="classSPUC_1_1array2d.html">array2d</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Array data is NOT copied, but shared. Thus, in <a class="el" href="classSPUC_1_1array2d.html">array2d</a> B(A), subsequent changes to A will be reflected in B. For an indepent copy of A, use <a class="el" href="classSPUC_1_1array2d.html">array2d</a> B(A.copy()), or B = A.copy(), instead. </p>

</div>
</div>
<a class="anchor" id="ab11d75e0a88c4bccf8fbcee6e416e701"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::~<a class="el" href="classSPUC_1_1array2d.html">array2d</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7099e0ef82df869dec72ae747091494b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac59ca10d58b6ea5c424ed2c78246c5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new of existing matrix. Used in B = A.copy() or in the construction of B, e.g. <a class="el" href="classSPUC_1_1array2d.html">array2d</a> B(A.copy()), to create a new array that does not share data. </p>

</div>
</div>
<a class="anchor" id="af3211b58437f320f4142c37428937fdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::dim1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the first dimension of the array, i.e. the number of rows. </dd></dl>

<p>Referenced by <a class="el" href="classSPUC_1_1array2d.html#a66fd6dc2770156025ef8e4a3765e2420">SPUC::array2d&lt; T &gt;::set_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a7aabe161e81fadee2e2fe35a15423ff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::dim2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the second dimension of the array, i.e. the number of columns. </dd></dl>

<p>Referenced by <a class="el" href="classSPUC_1_1array2d.html#a66fd6dc2770156025ef8e4a3765e2420">SPUC::array2d&lt; T &gt;::set_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c1e3863657ba94c774d9827d84c290a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp; <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::inject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the elements to from one array to another, in place. That is B.inject(A), both A and B must conform (i.e. have identical row and column dimensions).</p>
<p>This differs from B = A.copy() in that references to B before this assignment are also affected. That is, if we have </p><pre>
        <a class="el" href="classSPUC_1_1array2d.html">array2d</a> A(m,n);
        <a class="el" href="classSPUC_1_1array2d.html">array2d</a> C(m,n);
        <a class="el" href="classSPUC_1_1array2d.html">array2d</a> B(C);        // elements of B and C are shared.</pre><pre></pre><p> then B.inject(A) affects both and C, while B=A.copy() creates a new array B which shares no data with C or A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the array from elements will be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of the modifed array. That is, in B.inject(A), it returns B. If A and B are not conformat, no modifications to B are made. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3e857975d53953620ba05a51ec1683e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt;T&gt;&amp; <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::newsize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classSPUC_1_1array2d.html#a66fd6dc2770156025ef8e4a3765e2420">SPUC::array2d&lt; T &gt;::set_size()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSPUC_1_1array2d_ac3e857975d53953620ba05a51ec1683e_cgraph.png" border="0" usemap="#classSPUC_1_1array2d_ac3e857975d53953620ba05a51ec1683e_cgraph" alt=""/></div>
<map name="classSPUC_1_1array2d_ac3e857975d53953620ba05a51ec1683e_cgraph" id="classSPUC_1_1array2d_ac3e857975d53953620ba05a51ec1683e_cgraph">
<area shape="rect" id="node2" href="classSPUC_1_1array2d.html#a66fd6dc2770156025ef8e4a3765e2420" title="SPUC::array2d::set_size" alt="" coords="220,31,387,56"/><area shape="rect" id="node3" href="classSPUC_1_1array2d.html#af3211b58437f320f4142c37428937fdf" title="SPUC::array2d::dim1" alt="" coords="435,5,583,31"/><area shape="rect" id="node4" href="classSPUC_1_1array2d.html#a7aabe161e81fadee2e2fe35a15423ff8" title="SPUC::array2d::dim2" alt="" coords="435,55,583,80"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3b9e23c1c0fe0d5c0fa1956fac5ed292"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp; <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign all elemnts of A to a constant scalar. </p>

</div>
</div>
<a class="anchor" id="a03e8fc54006609111d84ed5f70c5e9d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp; <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>B = A is shorthand notation for B.ref(A). </p>

</div>
</div>
<a class="anchor" id="a4a5cddffb7c62e630c364548f6034fb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used for A[i][j] indexing. The first [] operator returns a conventional pointer which can be dereferenced using the same [] notation.</p>
<p>If TNT_BOUNDS_CHECK macro is define, the left-most index (row index) is checked that it falls within the array bounds (via the assert() macro.) Note that bounds checking can occur in the row dimension, but the not column, since this is just a C pointer. </p>

</div>
</div>
<a class="anchor" id="a68a4f1106ef6e3f90b63352dba1916aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2453eaf12d3927f74a46be1fb817b882"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp; <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a reference (shallow assignment) to another existing array. In B.ref(A), B and A shared the same data and subsequent changes to the array elements of one will be reflected in the other. </p>
<p>This is what operator= calls, and B=A and B.ref(A) are equivalent operations.</p>
<dl class="section return"><dt>Returns</dt><dd>The new referenced array: in B.ref(A), it returns B. </dd></dl>

</div>
</div>
<a class="anchor" id="abc6e791abe989e74dbae5746c2e37d90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::ref_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of arrays that share the same storage area as this one. (Must be at least one.) </dd></dl>

</div>
</div>
<a class="anchor" id="a3b8b4259781c0da8112d16e1fcf9dcdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66fd6dc2770156025ef8e4a3765e2420"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPUC_1_1array2d.html">array2d</a>&lt;T&gt;&amp; <a class="el" href="classSPUC_1_1array2d.html">SPUC::array2d</a>&lt; T &gt;::set_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="classSPUC_1_1array2d.html#af3211b58437f320f4142c37428937fdf">SPUC::array2d&lt; T &gt;::dim1()</a>, and <a class="el" href="classSPUC_1_1array2d.html#a7aabe161e81fadee2e2fe35a15423ff8">SPUC::array2d&lt; T &gt;::dim2()</a>.</p>

<p>Referenced by <a class="el" href="classSPUC_1_1array2d.html#ac3e857975d53953620ba05a51ec1683e">SPUC::array2d&lt; T &gt;::newsize()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classSPUC_1_1array2d_a66fd6dc2770156025ef8e4a3765e2420_cgraph.png" border="0" usemap="#classSPUC_1_1array2d_a66fd6dc2770156025ef8e4a3765e2420_cgraph" alt=""/></div>
<map name="classSPUC_1_1array2d_a66fd6dc2770156025ef8e4a3765e2420_cgraph" id="classSPUC_1_1array2d_a66fd6dc2770156025ef8e4a3765e2420_cgraph">
<area shape="rect" id="node2" href="classSPUC_1_1array2d.html#af3211b58437f320f4142c37428937fdf" title="SPUC::array2d::dim1" alt="" coords="221,5,368,31"/><area shape="rect" id="node3" href="classSPUC_1_1array2d.html#a7aabe161e81fadee2e2fe35a15423ff8" title="SPUC::array2d::dim2" alt="" coords="221,55,368,80"/></map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="array2d_8h.html">array2d.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 12 2014 21:03:53 for SPUC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
