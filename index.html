<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>SPUC: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SPUC
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SPUC Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Copyright (c) 1993-2005 Tony Kirke </p><dl class="section author"><dt>Author</dt><dd>= Tony Kirke</dd></dl>
<h1>DSP Templates</h1>
<p><b>Motivation:Why use C++ for DSP Simulation/Modeling?</b> </p>
<p>Todays IC and system designers typically use either C or costly 2<sup>nd</sup> party tools to simulate/model Digital Signal Processing algorithms. While the latter are well suited for modeling "hardwired" DSP blocks with rather simplistic dataflows, they are very inefficient for modeling the control logic that is often required in todays DSP applications (such as ADSL or V.34 modems). while C is well suited to control logic type structures (if,else, case, etc.), it is not highly desireable for manipulation of complex or user defined data types (such as fixed width integers). </p>
<p><em>C++ bridges this gap and is the underlying language of choice for the cumbersome GUI based tools.</em></p>
<hr/>
<p><b>Objective</b></p>
<p>The objective of DSP Templates is to provide DSP Algorithm designer with simple, efficient and reusable DSP building block objects. Thus allowing a transition from System design to implementation in either programmable DSP chips or hardwired DSP logic. While Matlab is perhaps the most useful available tool for this purpose, it can be quite slow for simulation and it favors a matrix/block based approach rather than the sample by sample simulations that are often most useful for communications systems design. Also Matlab is generally awkward or inefficient when dealing with several interactive feedback loops where C/C++ is perhaps the most useful environment. For bit-accurate simulations (for VLSI design) C/C++ generally outperforms and is easier to manipulate than Matlab or other GUI-based tools.</p>
<p>This Class Library</p>
<ul>
<li>
1) basic building blocks such as complex data types, Fixed-bit width integer classes, pure-delay blocks, etc. </li>
<li>
2) Basic DSP building blocks such as FIR, IIR, Allpass, Running Average, Lagrange interpolation filters, NCO, Cordic rotator. </li>
<li>
3) Several communications functions such as timing, phase and frequency discriminators for BPSK/QPSK signals. </li>
<li>
4) Other miscellaneous DSP/Communications related functions/classes. </li>
<li>
5) Ability to design several types of FIR and IIR filters </li>
<li>
6) Various adaptive equalizer classes </li>
<li>
7) This library now includes code from IT 3.7.0. </li>
<li>
8) Capitalized and uppercase class names are classes not originally in DSP Templates </li>
</ul>
<p>The classes are designed so that they can be used in a simple straight forward manner. For example, a FIR would be initialized with its tap weights and then simply a member function would be called every time a sample is input or an output is required.</p>
<p>Before discussing why C++ is better than C for DSP programming. Let's look at some of the pros and cons for C++ vs. the alternatives.</p>
<p><b>Pros</b></p>
<ul>
<li>
The common alternatives are very costly (Alta's SPW, Synopsys Cossap etc.) </li>
<li>
Long learning times/training not required for C++ programmers. </li>
<li>
For complex simulations, C++ is more efficient and yields shorter run times. </li>
<li>
Ideal for modeling a combination of control logic and hardwired DSP blocks. </li>
<li>
Code entry can be faster than GUI based tools. </li>
<li>
Looks closer to Verilog/VHDL than alternative tools. </li>
<li>
C/C++ has a large user base. </li>
<li>
Lots of freely available C/C++ code. </li>
<li>
Infinitely customizable. </li>
<li>
Portable to different platforms. </li>
<li>
Can take advantage of Windows GUIs if desired. </li>
</ul>
<p><b>Cons</b></p>
<ul>
<li>
No standardization! </li>
<li>
Lack of documentation. </li>
<li>
Not user friendly/ No GUI. </li>
<li>
Potential portability problems. </li>
<li>
No technical support. </li>
</ul>
<p>Please see links such as those below for why to use C++ over C in general.</p>
<p><br />
<a href="http://www.cantrip.org/cpp.html">Nathan Myers C++ Articles</a> <br />
<a href="http://math.nist.gov/pozo/c++class/">C++ Programming for Scientists Course (PDF) from NIST</a> <br />
<a href="http://math.nist.gov/pozo/">Various C++ Math classes from Roldan Pozo at NIST</a> </p>
<p><b>Advantages of C++ over C</b> </p><ul>
<li>
Object Oriented Language </li>
<li>
Abstract Data typing </li>
<li>
Inheritance </li>
<li>
Polymorphism </li>
<li>
Comments do not extend over more than one line </li>
<li>
Variables can be declared anywhere. </li>
<li>
Dynamic memory allocation is simpler. </li>
<li>
Function Overloading </li>
</ul>
<p><b>C++ allows templates and operator overloading.</b> <br />
For example, we can define a complex data type based on templates. Then this class can be used whether we need floating point (double), integer, or user defined fixed bit width data types.This not only requires less code to document/debug, but also through operator overloading we can make the code much easier to read and potentially make the look and feel very close to a Hardware Description Language (HDL)such as Verilog or VHDL. Also this style makes it much easier to change your programs data types (from floating point -&gt; integer -&gt; fixed bit width for example), without having to change every line of code. </p>
<p><b>C++ allows for much better interfaces between classes or DSP blocks.</b> <br />
Because C++ supports initialization through constructors and there can be a variety of member functions, data can be handled in a much smoother manner than C. With data hiding, the code becomes much simpler to read, allowing a high level look at the code.</p>
<p><b>Inheritance</b> <br />
Inheritance helps you to re-use code.You can derive new types or classes from an old one and make changes only where you need them. This promotes code re-use. </p>
<p><b>Classes</b> </p><ul>
<li>
Hide complexity. </li>
<li>
Create a more convenient object oriented interfaces </li>
<li>
Can create more than one instance of a structure. </li>
<li>
Similar to C structure but can include functions. </li>
<li>
Data abstraction and hiding allows changes to be localized to one section. </li>
<li>
Private, Protected, Public members</li>
</ul>
<p><b>For Hardware Modeling</b> <br />
C++ can be made to replicate hardware much easier than C. Functions and variables can be localised to each block (hiding complexity) in the same way that Verilog /VHDL does. Easier to have a hierarchical structure. Classes can be instantiated in same manner as in a HDL (C makes this difficult). New chip designs can inherit subblocks or a large section from an old design. Only the new or changed blocks need to be coded. Also the interfaces to the chip can remain the same if desired. When classes are designed in this manner it is quite easy to see the difference between objects. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 12 2014 21:03:54 for SPUC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
